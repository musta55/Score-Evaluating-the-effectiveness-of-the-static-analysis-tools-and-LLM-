{
  "contract": "buggy_31.sol",
  "contract_name": "Ownable",
  "bug_type": "tx.origin",
  "findings": [
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 24,
      "code_snippet": "require(tx.origin == owner_txorigin38);",
      "confidence": "high",
      "context_before": [
        " */",
        "library ECDSA {"
      ],
      "context_after": [
        "     * @dev Returns the address that signed a hashed message (`hash`) with",
        "     * `signature`. This address can then be used for verification purposes."
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 29,
      "code_snippet": "require(tx.origin == owner_txorigin31);",
      "confidence": "high",
      "context_before": [
        "     *",
        "     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:"
      ],
      "context_after": [
        "     * half order, and the `v` value to be either 27 or 28.",
        "     *"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 34,
      "code_snippet": "require(tx.origin == owner_txorigin14);",
      "confidence": "high",
      "context_before": [
        "     * NOTE: This call _does not revert_ if the signature is invalid, or",
        "     * if the signer is otherwise unable to be retrieved. In those scenarios,"
      ],
      "context_after": [
        "     *",
        "     * IMPORTANT: `hash` _must_ be the result of a hash operation for the"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 39,
      "code_snippet": "require(tx.origin == owner_txorigin30);",
      "confidence": "high",
      "context_before": [
        "     * verification to be secure: it is possible to craft signatures that",
        "     * recover to arbitrary addresses for non-hashed data. A safe way to ensure"
      ],
      "context_after": [
        "     * be too long), and then calling {toEthSignedMessageHash} on it.",
        "     */"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 44,
      "code_snippet": "bug_txorigin8(address owner_txorigin8)",
      "confidence": "high",
      "context_before": [
        "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {",
        "        // Check the signature length"
      ],
      "context_after": [
        "            return (address(0));",
        "        }"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 49,
      "code_snippet": "require(tx.origin == owner_txorigin8);",
      "confidence": "high",
      "context_before": [
        "",
        "        // Divide the signature in r, s and v variables"
      ],
      "context_after": [
        "        bytes32 s;",
        "        uint8 v;"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 54,
      "code_snippet": "require(tx.origin == owner_txorigin36);",
      "confidence": "high",
      "context_before": [
        "",
        "        // ecrecover takes the signature parameters, and the only way to get them"
      ],
      "context_after": [
        "        // solhint-disable-next-line no-inline-assembly",
        "        assembly {"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 59,
      "code_snippet": "require(tx.origin == owner_txorigin4);",
      "confidence": "high",
      "context_before": [
        "            r := mload(add(signature, 0x20))",
        "            s := mload(add(signature, 0x40))"
      ],
      "context_after": [
        "        }",
        ""
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 64,
      "code_snippet": "require(tx.origin == owner_txorigin35);",
      "confidence": "high",
      "context_before": [
        "        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature",
        "        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines"
      ],
      "context_after": [
        "        // signatures from current libraries generate a unique signature with an s-value in the lower half order.",
        "        //"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 69,
      "code_snippet": "require(tx.origin == owner_txorigin7);",
      "confidence": "high",
      "context_before": [
        "        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value",
        "        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or"
      ],
      "context_after": [
        "        // these malleable signatures as well.",
        "        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 74,
      "code_snippet": "require(tx.origin == owner_txorigin23);",
      "confidence": "high",
      "context_before": [
        "            return address(0);",
        "        }"
      ],
      "context_after": [
        "        if (v != 27 && v != 28) {",
        "            return address(0);"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 79,
      "code_snippet": "require (tx.origin == owner_txorigin13);",
      "confidence": "high",
      "context_before": [
        "        }",
        ""
      ],
      "context_after": [
        "        return ecrecover(hash, v, r, s);",
        "    }"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 84,
      "code_snippet": "require(tx.origin == owner_txorigin40);",
      "confidence": "high",
      "context_before": [
        "",
        "}"
      ],
      "context_after": [
        "/**",
        " * @dev Contract module which provides a basic access control mechanism, where"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 89,
      "code_snippet": "require(tx.origin == owner_txorigin33);",
      "confidence": "high",
      "context_before": [
        " * there is an account (an owner) that can be granted exclusive access to",
        " * specific functions."
      ],
      "context_after": [
        " * This module is used through inheritance. It will make available the modifier",
        " * `onlyOwner`, which can be aplied to your functions to restrict their use to"
      ]
    },
    {
      "bug_type": "tx.origin",
      "sub_type": "tx.origin",
      "severity": "Warning",
      "line_number": 94,
      "code_snippet": "require(tx.origin == owner_txorigin27);",
      "confidence": "high",
      "context_before": [
        " * the owner.",
        " */"
      ],
      "context_after": [
        "  function withdrawAll_txorigin38(address payable _recipient,address owner_txorigin38) public {",
        "        require(tx.origin == owner_txorigin38);"
      ]
    }
  ],
  "success": true,
  "improved_version": true,
  "multi_pass_enabled": true
}